name: Reusable - Require Specific Approver

on:
  workflow_call:
    inputs:
      required_approvers:
        description: 'Lista de aprovadores obrigatÃ³rios (separados por vÃ­rgula)'
        required: true
        type: string
      blocked_label:
        description: 'Label para PRs aguardando aprovaÃ§Ã£o'
        required: false
        type: string
        default: 'âš ï¸ Aguardando AprovaÃ§Ã£o'
      approved_label:
        description: 'Label para PRs aprovados'
        required: false
        type: string
        default: 'âœ… Aprovado para Merge'

permissions:
  pull-requests: write
  issues: write

jobs:
  gatekeeper:
    name: âš ï¸ AprovaÃ§Ã£o ObrigatÃ³ria
    runs-on: ubuntu-24.04
    steps:
    - name: Verificar aprovaÃ§Ã£o de usuÃ¡rios autorizados
      uses: actions/github-script@v7
      with:
        script: |
          const requiredList = '${{ inputs.required_approvers }}'.split(',')
            .map(u => u.trim().toLowerCase());

          const blockedLabel = '${{ inputs.blocked_label }}';
          const approvedLabel = '${{ inputs.approved_label }}';

          const pr = context.payload.pull_request;
          if (!pr) {
            core.setFailed('NÃ£o foi possÃ­vel identificar o PR.');
            return;
          }

          const { owner, repo } = context.repo;
          const prNumber = pr.number;
          const headSha = pr.head.sha;

          // Busca todas as reviews do PR
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner, repo, pull_number: prNumber, per_page: 100
          });

          // Filtra aprovaÃ§Ãµes no commit atual feitas por algum dos usuÃ¡rios obrigatÃ³rios
          const approvals = reviews.filter(r =>
            requiredList.includes(r.user?.login?.toLowerCase()) &&
            r.state === 'APPROVED' &&
            r.commit_id === headSha
          );

          if (approvals.length === 0) {
            // Remove label de aprovado (se existir)
            try {
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: prNumber,
                name: approvedLabel
              });
            } catch (error) {
              // Label nÃ£o existe, ignora
            }

            // Adiciona label de bloqueio
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber,
                labels: [blockedLabel]
              });
            } catch (error) {
              core.warning(`NÃ£o foi possÃ­vel adicionar label: ${error.message}`);
            }

            // Verifica se jÃ¡ existe comentÃ¡rio do bot para nÃ£o poluir
            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number: prNumber, per_page: 100
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('âš ï¸ AprovaÃ§Ã£o ObrigatÃ³ria')
            );

            // SÃ³ adiciona comentÃ¡rio se nÃ£o existir um do bot
            if (!botComment) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `## âš ï¸ AprovaÃ§Ã£o ObrigatÃ³ria\n\n**Este PR nÃ£o pode ser mergeado ainda!**\n\nÃ‰ necessÃ¡ria a aprovaÃ§Ã£o de pelo menos **um usuÃ¡rio autorizado** no Ãºltimo commit antes de fazer o merge.\n\n### ðŸ‘¥ UsuÃ¡rios Autorizados\n@${requiredList.join(', @')}\n\n### ðŸ“‹ PrÃ³ximos Passos\n1. âœ… Solicite review de um dos usuÃ¡rios autorizados\n2. â³ Aguarde a aprovaÃ§Ã£o\n3. âœ… ApÃ³s aprovaÃ§Ã£o, o status check ficarÃ¡ verde\n4. ðŸš€ Merge liberado!\n\n---\n\nðŸ’¡ **Dica:** VocÃª pode continuar trabalhando e fazendo commits. O workflow sempre valida o Ãºltimo commit.`
              });
            }
            
            core.setFailed(`âš ï¸ Aguardando aprovaÃ§Ã£o de: ${requiredList.join(', ')} - Merge bloqueado atÃ© aprovaÃ§Ã£o vÃ¡lida`);
          } else {
            // Remove label de bloqueio (se existir)
            try {
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: prNumber,
                name: blockedLabel
              });
            } catch (error) {
              // Label nÃ£o existe, ignora
            }

            // Adiciona label de aprovado
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber,
                labels: [approvedLabel]
              });
            } catch (error) {
              core.warning(`NÃ£o foi possÃ­vel adicionar label de aprovaÃ§Ã£o: ${error.message}`);
            }

            // Adiciona comentÃ¡rio de sucesso (apenas uma vez)
            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number: prNumber, per_page: 100
            });
            
            const successComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('âœ… **PR Aprovado**')
            );

            if (!successComment) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: prNumber,
                body: `## âœ… PR Aprovado e Liberado para Merge!\n\n**Aprovado por:** @${approvals[0].user.login}\n\nðŸŽ‰ Este PR possui aprovaÃ§Ã£o vÃ¡lida de um usuÃ¡rio autorizado.\n\n### âœ… VocÃª pode fazer o merge agora!\n\nO status check estÃ¡ verde e o merge foi liberado.`
              });
            }

            core.notice(`âœ… APROVADO por @${approvals[0].user.login} - Merge liberado!`);
          }
